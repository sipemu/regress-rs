//! R Validation Tests for WLS, Ridge, Elastic Net, and Tweedie.
//!
//! These tests compare anofox-regression implementations against R's output.
//! Data generated by tests/r_scripts/generate_regression_validation.R

use anofox_regression::solvers::{
    ElasticNetRegressor, FittedRegressor, Regressor, RidgeRegressor, TweedieRegressor, WlsRegressor,
};
use approx::assert_relative_eq;
use faer::{Col, Mat};

// =============================================================================
// WLS (Weighted Least Squares) - R validation
// =============================================================================
// R Code: lm(y ~ x, weights = w)

const X_WLS: [f64; 20] = [
    1.000000, 2.000000, 3.000000, 4.000000, 5.000000, 6.000000, 7.000000, 8.000000, 9.000000,
    10.000000, 11.000000, 12.000000, 13.000000, 14.000000, 15.000000, 16.000000, 17.000000,
    18.000000, 19.000000, 20.000000,
];
const Y_WLS: [f64; 20] = [
    4.985479, 5.535302, 8.444693, 10.965725, 12.510671, 12.981626, 20.390327, 16.521364, 27.782907,
    20.186430, 29.476783, 37.819872, 16.872405, 25.748479, 28.500090, 36.387603, 30.683850,
    10.991901, 13.515564, 51.701133,
];
const W_WLS: [f64; 20] = [
    1.0000000000,
    0.2500000000,
    0.1111111111,
    0.0625000000,
    0.0400000000,
    0.0277777778,
    0.0204081633,
    0.0156250000,
    0.0123456790,
    0.0100000000,
    0.0082644628,
    0.0069444444,
    0.0059171598,
    0.0051020408,
    0.0044444444,
    0.0039062500,
    0.0034602076,
    0.0030864198,
    0.0027700831,
    0.0025000000,
];
const EXPECTED_INTERCEPT_WLS: f64 = 3.1054941162;
const EXPECTED_COEF_WLS: f64 = 1.7870395000;
const EXPECTED_SE_INTERCEPT_WLS: f64 = 0.6773163273;
const EXPECTED_SE_COEF_WLS: f64 = 0.1913441548;
const EXPECTED_R_SQUARED_WLS: f64 = 0.8289369865;

#[test]
fn test_r_validation_wls() {
    let x = Mat::from_fn(20, 1, |i, _| X_WLS[i]);
    let y = Col::from_fn(20, |i| Y_WLS[i]);
    let w = Col::from_fn(20, |i| W_WLS[i]);

    let fitted = WlsRegressor::builder()
        .with_intercept(true)
        .weights(w)
        .compute_inference(true)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let result = fitted.result();
    let intercept = result.intercept.unwrap();
    let coef = result.coefficients[0];

    // R-validated coefficients
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_WLS, epsilon = 0.01);
    assert_relative_eq!(coef, EXPECTED_COEF_WLS, epsilon = 0.01);

    // R-validated R²
    assert_relative_eq!(result.r_squared, EXPECTED_R_SQUARED_WLS, epsilon = 0.01);

    // R-validated standard errors
    let se = result.std_errors.as_ref().expect("SE should exist");
    let se_intercept = result.intercept_std_error.expect("intercept SE");
    assert_relative_eq!(se_intercept, EXPECTED_SE_INTERCEPT_WLS, epsilon = 0.01);
    assert_relative_eq!(se[0], EXPECTED_SE_COEF_WLS, epsilon = 0.01);
}

// =============================================================================
// Ridge Regression - R validation (closed-form)
// =============================================================================
// Validates against closed-form Ridge solution: β = (X'X + λI)^(-1) X'y
// This tests the mathematical definition directly (not glmnet's specific scaling)

const N_RIDGE: usize = 50;
const P_RIDGE: usize = 3;
#[rustfmt::skip]
const X_RIDGE: [f64; 150] = [
    1.370958, -0.564698, 0.363128, 0.632863, 0.404268, -0.106125, 1.511522, -0.094659,
    2.018424, -0.062714, 1.304870, 2.286645, -1.388861, -0.278789, -0.133321, 0.635950,
    -0.284253, -2.656455, -2.440467, 1.320113, -0.306639, -1.781308, -0.171917, 1.214675,
    1.895193, -0.430469, -0.257269, -1.763163, 0.460097, -0.639995, 0.455450, 0.704837,
    1.035104, -0.608926, 0.504955, -1.717009, -0.784459, -0.850908, -2.414208, 0.036123,
    0.205999, -0.361057, 0.758163, -0.726705, -1.368281, 0.432818, -0.811393, 1.444101,
    -0.431446, 0.655648, 0.321925, -0.783839, 1.575728, 0.642899, 0.089761, 0.276551,
    0.679289, 0.089833, -2.993090, 0.284883, -0.367235, 0.185231, 0.581824, 1.399737,
    -0.727292, 1.302543, 0.335848, 1.038506, 0.920729, 0.720878, -1.043119, -0.090186,
    0.623518, -0.953523, -0.542829, 0.580996, 0.768179, 0.463768, -0.885776, -1.099781,
    1.512707, 0.257921, 0.088440, -0.120897, -1.194329, 0.611997, -0.217140, -0.182757,
    0.933346, 0.821773, 1.392116, -0.476174, 0.650349, 1.391110, -1.110789, -0.860793,
    -1.131739, -1.459214, 0.079983, 0.653204, 1.200965, 1.044751, -1.003209, 1.848482,
    -0.666773, 0.105514, -0.422256, -0.122350, 0.188193, 0.119161, -0.025093, 0.108073,
    -0.485435, -0.504217, -1.661099, -0.382334, -0.512650, 2.701891, -1.362116, 0.137256,
    -1.493625, -1.470436, 0.124702, -0.996639, -0.001823, -0.428259, -0.613672, -2.024678,
    -1.224748, 0.179516, 0.567621, -0.492877, 0.000063, 1.122890, 1.439856, -1.097114,
    -0.117320, 1.201498, -0.469730, -0.052469, -0.086107, -0.887679, -0.444684, -0.029445,
    -0.413869, 1.113386, -0.480993, -0.433169, 0.696863, -1.056368,
];
#[rustfmt::skip]
const Y_RIDGE: [f64; 50] = [
    1.992721, 0.467234, -2.524782, 0.450913, -0.140428, -1.278658, 0.693696, -0.782971,
    8.841166, 0.039581, 2.591465, 2.577652, -3.408053, -3.651135, 0.719059, -1.126116,
    -1.850747, -4.483425, -6.140767, 1.054825, 0.764578, -2.808498, -2.315089, 4.075469,
    4.359926, -2.097214, -2.953601, -4.263114, 2.090922, 1.326150, -1.982701, 0.002920,
    1.560210, 0.037176, 3.726389, -5.016182, -0.450694, -0.033000, -6.141022, -2.412891,
    -2.415809, -0.205622, -0.259488, -4.534002, -0.517363, 3.470393, 1.007779, 5.161239,
    0.448911, -0.786710,
];
// Closed-form Ridge: ||y - Xβ||² + λ||β||²
const LAMBDA_RIDGE: f64 = 0.5000000000;
const EXPECTED_INTERCEPT_RIDGE: f64 = -0.0144957200;
const EXPECTED_COEFS_RIDGE: [f64; 3] = [1.5356784685, -2.0011786069, 0.4733624453];

#[test]
fn test_r_validation_ridge() {
    // Build matrix from column-major data
    let x = Mat::from_fn(N_RIDGE, P_RIDGE, |i, j| X_RIDGE[i + j * N_RIDGE]);
    let y = Col::from_fn(N_RIDGE, |i| Y_RIDGE[i]);

    // Using Raw lambda scaling (default) for direct closed-form comparison
    // Objective: ||y - Xβ||² + λ||β||²
    let fitted = RidgeRegressor::builder()
        .with_intercept(true)
        .lambda(LAMBDA_RIDGE)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let intercept = fitted.result().intercept.unwrap();
    let coefs = &fitted.result().coefficients;

    // R-validated coefficients (closed-form solution)
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_RIDGE, epsilon = 0.01);
    assert_relative_eq!(coefs[0], EXPECTED_COEFS_RIDGE[0], epsilon = 0.01);
    assert_relative_eq!(coefs[1], EXPECTED_COEFS_RIDGE[1], epsilon = 0.01);
    assert_relative_eq!(coefs[2], EXPECTED_COEFS_RIDGE[2], epsilon = 0.01);
}

// =============================================================================
// Elastic Net - R validation (closed-form approximation)
// =============================================================================
// Uses the same data as Ridge (X_RIDGE, Y_RIDGE)
// Objective: ||y - Xβ||² + λ*(1-α)*||β||² + λ*α*||β||₁
// Note: Coordinate descent may produce slightly different results

const ALPHA_ENET: f64 = 0.5000000000;
const LAMBDA_ENET: f64 = 0.3000000000;
const EXPECTED_INTERCEPT_ENET: f64 = -0.0338808643;
const EXPECTED_COEFS_ENET: [f64; 3] = [1.4657678573, -1.9413016960, 0.4015506074];

#[test]
fn test_r_validation_elastic_net() {
    let x = Mat::from_fn(N_RIDGE, P_RIDGE, |i, j| X_RIDGE[i + j * N_RIDGE]);
    let y = Col::from_fn(N_RIDGE, |i| Y_RIDGE[i]);

    // Using Raw lambda scaling (default) for direct closed-form comparison
    let fitted = ElasticNetRegressor::builder()
        .with_intercept(true)
        .lambda(LAMBDA_ENET)
        .alpha(ALPHA_ENET)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let intercept = fitted.result().intercept.unwrap();
    let coefs = &fitted.result().coefficients;

    // R-validated coefficients (with tolerance for coordinate descent differences)
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_ENET, epsilon = 0.2);
    assert_relative_eq!(coefs[0], EXPECTED_COEFS_ENET[0], epsilon = 0.2);
    assert_relative_eq!(coefs[1], EXPECTED_COEFS_ENET[1], epsilon = 0.2);
    assert_relative_eq!(coefs[2], EXPECTED_COEFS_ENET[2], epsilon = 0.2);
}

// =============================================================================
// Tweedie GLM - Gamma (var.power = 2) - R validation
// =============================================================================
// R Code: glm(y ~ x, family = tweedie(var.power = 2, link.power = 0))

const X_TWEEDIE_GAMMA: [f64; 30] = [
    0.500000, 0.586207, 0.672414, 0.758621, 0.844828, 0.931034, 1.017241, 1.103448, 1.189655,
    1.275862, 1.362069, 1.448276, 1.534483, 1.620690, 1.706897, 1.793103, 1.879310, 1.965517,
    2.051724, 2.137931, 2.224138, 2.310345, 2.396552, 2.482759, 2.568966, 2.655172, 2.741379,
    2.827586, 2.913793, 3.000000,
];
const Y_TWEEDIE_GAMMA: [f64; 30] = [
    3.674048, 0.925590, 1.682034, 0.504913, 1.586715, 0.960427, 6.179875, 1.825446, 0.616511,
    0.386211, 5.035883, 4.321588, 4.225195, 3.387172, 4.757937, 1.128609, 2.006831, 8.698692,
    8.152989, 3.821331, 3.799281, 2.193752, 0.253188, 1.252328, 4.859668, 5.930911, 7.491828,
    2.163520, 2.012775, 1.896947,
];
const EXPECTED_INTERCEPT_TWEEDIE_GAMMA: f64 = 0.6335002809;
const EXPECTED_COEF_TWEEDIE_GAMMA: f64 = 0.2899130705;
const EXPECTED_DEVIANCE_TWEEDIE_GAMMA: f64 = 19.1528657743;

#[test]
fn test_r_validation_tweedie_gamma() {
    let x = Mat::from_fn(30, 1, |i, _| X_TWEEDIE_GAMMA[i]);
    let y = Col::from_fn(30, |i| Y_TWEEDIE_GAMMA[i]);

    let fitted = TweedieRegressor::gamma()
        .with_intercept(true)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let intercept = fitted.result().intercept.unwrap();
    let coef = fitted.result().coefficients[0];

    // R-validated coefficients and deviance
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_TWEEDIE_GAMMA, epsilon = 0.05);
    assert_relative_eq!(coef, EXPECTED_COEF_TWEEDIE_GAMMA, epsilon = 0.05);
    assert_relative_eq!(
        fitted.deviance,
        EXPECTED_DEVIANCE_TWEEDIE_GAMMA,
        epsilon = 0.5
    );
}

// =============================================================================
// Tweedie GLM - Poisson (var.power = 1) - R validation
// =============================================================================
// R Code: glm(y ~ x, family = tweedie(var.power = 1, link.power = 0))

const X_TWEEDIE_POISSON: [f64; 30] = [
    0.100000, 0.200000, 0.300000, 0.400000, 0.500000, 0.600000, 0.700000, 0.800000, 0.900000,
    1.000000, 1.100000, 1.200000, 1.300000, 1.400000, 1.500000, 1.600000, 1.700000, 1.800000,
    1.900000, 2.000000, 2.100000, 2.200000, 2.300000, 2.400000, 2.500000, 2.600000, 2.700000,
    2.800000, 2.900000, 3.000000,
];
const Y_TWEEDIE_POISSON: [f64; 30] = [
    4.000000, 4.000000, 1.000000, 4.000000, 3.000000, 3.000000, 4.000000, 1.000000, 4.000000,
    5.000000, 4.000000, 5.000000, 8.000000, 3.000000, 5.000000, 10.000000, 12.000000, 4.000000,
    7.000000, 8.000000, 13.000000, 6.000000, 17.000000, 6.000000, 16.000000, 16.000000, 17.000000,
    17.000000, 20.000000, 14.000000,
];
const EXPECTED_INTERCEPT_TWEEDIE_POISSON: f64 = 0.7992280825;
const EXPECTED_COEF_TWEEDIE_POISSON: f64 = 0.7108390190;
const EXPECTED_DEVIANCE_TWEEDIE_POISSON: f64 = 28.7548454444;

#[test]
fn test_r_validation_tweedie_poisson() {
    let x = Mat::from_fn(30, 1, |i, _| X_TWEEDIE_POISSON[i]);
    let y = Col::from_fn(30, |i| Y_TWEEDIE_POISSON[i]);

    let fitted = TweedieRegressor::poisson()
        .with_intercept(true)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let intercept = fitted.result().intercept.unwrap();
    let coef = fitted.result().coefficients[0];

    // R-validated coefficients and deviance
    assert_relative_eq!(
        intercept,
        EXPECTED_INTERCEPT_TWEEDIE_POISSON,
        epsilon = 0.01
    );
    assert_relative_eq!(coef, EXPECTED_COEF_TWEEDIE_POISSON, epsilon = 0.01);
    assert_relative_eq!(
        fitted.deviance,
        EXPECTED_DEVIANCE_TWEEDIE_POISSON,
        epsilon = 0.1
    );
}

// =============================================================================
// Tweedie GLM - Inverse Gaussian (var.power = 3) - R validation
// =============================================================================
// R Code: glm(y ~ x, family = tweedie(var.power = 3, link.power = 0))

const X_TWEEDIE_INVGAUSS: [f64; 30] = [
    0.500000, 0.586207, 0.672414, 0.758621, 0.844828, 0.931034, 1.017241, 1.103448, 1.189655,
    1.275862, 1.362069, 1.448276, 1.534483, 1.620690, 1.706897, 1.793103, 1.879310, 1.965517,
    2.051724, 2.137931, 2.224138, 2.310345, 2.396552, 2.482759, 2.568966, 2.655172, 2.741379,
    2.827586, 2.913793, 3.000000,
];
const Y_TWEEDIE_INVGAUSS: [f64; 30] = [
    0.520746, 3.077116, 2.684075, 1.062602, 3.095093, 1.926178, 0.518001, 2.596461, 0.357832,
    2.379919, 0.663142, 0.303635, 0.633964, 2.156652, 2.680012, 7.339561, 2.382664, 0.246063,
    0.286626, 0.751036, 2.654481, 0.493492, 3.462012, 0.888767, 0.457298, 2.594986, 3.505298,
    0.526974, 2.697976, 2.090898,
];
const EXPECTED_INTERCEPT_TWEEDIE_INVGAUSS: f64 = 0.5425475443;
const EXPECTED_COEF_TWEEDIE_INVGAUSS: f64 = 0.0364510123;
const EXPECTED_DEVIANCE_TWEEDIE_INVGAUSS: f64 = 19.6421879799;

#[test]
fn test_r_validation_tweedie_inverse_gaussian() {
    let x = Mat::from_fn(30, 1, |i, _| X_TWEEDIE_INVGAUSS[i]);
    let y = Col::from_fn(30, |i| Y_TWEEDIE_INVGAUSS[i]);

    let fitted = TweedieRegressor::inverse_gaussian()
        .with_intercept(true)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let intercept = fitted.result().intercept.unwrap();
    let coef = fitted.result().coefficients[0];

    // R-validated coefficients and deviance
    assert_relative_eq!(
        intercept,
        EXPECTED_INTERCEPT_TWEEDIE_INVGAUSS,
        epsilon = 0.1
    );
    assert_relative_eq!(coef, EXPECTED_COEF_TWEEDIE_INVGAUSS, epsilon = 0.1);
    assert_relative_eq!(
        fitted.deviance,
        EXPECTED_DEVIANCE_TWEEDIE_INVGAUSS,
        epsilon = 1.0
    );
}

// =============================================================================
// Tweedie GLM - Compound Poisson-Gamma (var.power = 1.5) - R validation
// =============================================================================
// R Code: glm(y ~ x, family = tweedie(var.power = 1.5, link.power = 0))

const X_TWEEDIE_CPG: [f64; 30] = [
    0.500000, 0.586207, 0.672414, 0.758621, 0.844828, 0.931034, 1.017241, 1.103448, 1.189655,
    1.275862, 1.362069, 1.448276, 1.534483, 1.620690, 1.706897, 1.793103, 1.879310, 1.965517,
    2.051724, 2.137931, 2.224138, 2.310345, 2.396552, 2.482759, 2.568966, 2.655172, 2.741379,
    2.827586, 2.913793, 3.000000,
];
const Y_TWEEDIE_CPG: [f64; 30] = [
    1.961966, 1.000101, 0.001000, 0.610909, 1.086285, 4.708548, 4.413162, 0.001000, 2.056527,
    1.187464, 0.137049, 0.677877, 2.630508, 0.001000, 4.055280, 1.171100, 1.089502, 0.001000,
    3.520664, 1.803962, 2.896406, 0.001000, 2.997140, 0.559834, 0.001000, 1.309568, 4.775728,
    3.234757, 4.101226, 1.558000,
];
const EXPECTED_INTERCEPT_TWEEDIE_CPG: f64 = 0.1820182571;
const EXPECTED_COEF_TWEEDIE_CPG: f64 = 0.2192857067;
const EXPECTED_DEVIANCE_TWEEDIE_CPG: f64 = 47.8045351436;

#[test]
fn test_r_validation_tweedie_cpg() {
    let x = Mat::from_fn(30, 1, |i, _| X_TWEEDIE_CPG[i]);
    let y = Col::from_fn(30, |i| Y_TWEEDIE_CPG[i]);

    let fitted = TweedieRegressor::builder()
        .var_power(1.5)
        .link_power(0.0)
        .with_intercept(true)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let intercept = fitted.result().intercept.unwrap();
    let coef = fitted.result().coefficients[0];

    // R-validated coefficients and deviance
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_TWEEDIE_CPG, epsilon = 0.2);
    assert_relative_eq!(coef, EXPECTED_COEF_TWEEDIE_CPG, epsilon = 0.2);
    assert_relative_eq!(
        fitted.deviance,
        EXPECTED_DEVIANCE_TWEEDIE_CPG,
        epsilon = 5.0
    );
}
